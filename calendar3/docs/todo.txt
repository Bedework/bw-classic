Todo

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Try a change and see if we get mailed.
--------------------------------------------------------------------------------
Web-client - ensure no unexpected data modifications.
--------------------------------------------------------------------------------
Check all day events are correct in all clients.
--------------------------------------------------------------------------------
Finish off moving calendar labelling stuff out of TimeDateComponents
am/pm etc.
--------------------------------------------------------------------------------
Floating times should be as the result of an explicit user request.
--------------------------------------------------------------------------------
eventIcal
Need to use action to deliver ical - not stylesheet
--------------------------------------------------------------------------------
What was I trying to do with the default access stuff in the principal?
There must be a better way - or maybe I've got it the wrong way round.

I think I must have decided that the principal was a reasonable place to store
the default access for that principals locations etc. In effect the principal
is the container for that stuff.
--------------------------------------------------------------------------------
The EventAnnotation class was causing multiple queries - (polymorphic queries)
For example, the hql "select count(*) from BwEvents where ..."
caused 2 queries and a non-unique result exception

Fixed by changing the hierarchy, making BwEvent a common base class then
subclass for BwEventObj and BwEventAnnotation.
--------------------------------------------------------------------------------
FiltersRule needs to add Inbox
CalintfImpl and FiltersRule should use some joint code to create users.
Try init of empty system then create users through Calintf?
--------------------------------------------------------------------------------
lazy="false" is set on calendar objects.
--------------------------------------------------------------------------------
Acl.encode should not encode Ace with inherited = true
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Need to ensure update doesn't change the guid
--------------------------------------------------------------------------------
Fix the add event link in calendar gui
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
We probably need the equivalent of an event info object at the Calintf level to
contain transient information about the event. Should hold:
  a. Overrides
  b. Allowed access (read/write)

Information can be copied into the EventInfo object.
--------------------------------------------------------------------------------
Notes on annotations and overriddes and fetching events.
Allowing users to annotate shared events introduces enormous complexity to the
fetching and updating process but seems to be a feature of enterprise systems.

Until we feel this is workable we may want to supress annotations in the user
interface. HOWEVER, synchml and caldav sort of make this a requirement.

Those protocols have no concept of ownership. If we create a calendar then add
refeences to events we don't own, either through subscription or adding a
reference, when we synch the target device will just see a set of events all
apppearing to be owned by the user. They may go ahead and update such an event
and we have the choice of preserving those changes as annotations or losing them
on synch.

We don't need to CREATE annotations on fetch but we do need to FETCH any owned
by the current user.

I. Single event fetch
Assume fetch for read:

1. Fetch event. BUT see note about shared annotations. The event may have
   appeared as the result of an annotation by another user. I don't think we
   can always know that to be the case - especially if we use other access
   methods (synchml, caldav)
2. If event owned by someone else look for an annotation and build proxy if
   found. NOTE - the recurrence id is null for an annotation of a master event

NOTE - an  annotation of a master will not be reflected in any of the
instances at this stage.

If it's non recurring or we want master only we're done.

If we're asked to retrieve overrides only we fetch all annotations with
annotation.master = master. Note that is not the annotation target but the
ultimate master event we are searching for.

The possibilities:
A. We're the owner
  1. Fetch any overrides we own with
        annotation.master = master and recurrence id not null
  2. If there are no overrides we're done
  3. Add proxied overrides to result and return.

B. We're not the owner
  1. Fetch any overrides we own or owned by the master owner
        annotation.master = master and recurrence id not null
  2. If there are no overrides we're done
  3. Reconstruct proxies for each override and add to result.

It appears the only difference is in the ownership clause.

A third case is we are asked to return all instances associated with an event.
This may be the case for export of an expanded recurring event. (or maybe
fetch via caldav?)

We should do the fetch above, then fetch all recurrence instances. Then

For each instance:
  If there is an overrride create a proxy for the override and add to the result
  If ther is no override, craete a dummy annotation and proxy and add.

Return the final result.

II Fetching events (date range)

1. Query for events which satisfy the requirements and filter down to events
   for which we have read access.

2. Query for annotations we own in the range for which master is in
   the set of retrieved events which we don't own.

   What does this mean? We queried /public/Arts for events none of which we own.
   We query annotations for the same time range in the same calendar.

3. Build proxies for overriden events

If we got no recurring events in the set we're done so return.

Otherwise:
1. Fetch any instances in the date range

2. If we were asked for master only return unique master events for which we
   have access

3. Fetch any overrides with appropriate owneship
      a. in the same calendar
      b. with a master in the set of recurring masters we retrieved in step 1

4. Iterate over instances creating dummies for non overriden and attaching
   overrides where found.
--------------------------------------------------------------------------------
Do we share annotations?
For example:
We have event A

User P has annotation on A in their calendar. Is that visible to others? I
believe so - though the referenced event may not be.

User Q sees P:annotation(A) and annotates.
--------------------------------------------------------------------------------
Updating an event for which user has read access
Having fetched it it is up to the client side to create a proxy to an
unannotated event if the user wants to modify it. So the client does a fetch,
if we have write access just update the event, if we have read access then
add an annotation and proxy.

Note that this turns the update into an addition of an annotation at first write.
--------------------------------------------------------------------------------
Updates to annotated events by the owner.

Further complications arise if an annotated instance without an override is
overridden by a user with write access. The original annotation is now invalid.
First problem is to locate those annotations, second is to figure out what to
do.

We could add a status to the annotation indicating the underlying object changed.
Should we retarget the annotation?

In the web client we can warn the user. Send email?
--------------------------------------------------------------------------------
Access changed on event.
If access changed to none the annotated event becomes invisible.

If access changed to write there may still be an anootation attached. We may
want to allow annotations of events for which user has mod access anyway
--------------------------------------------------------------------------------
Add an inbox calendar - do we want outbox? Put proxy in outbox?
Delete proxy
--------------------------------------------------------------------------------
Recurrences - ask that add not be removed - just limit to 1 instance
     Feb 31st - RFC2445 page 44
--------------------------------------------------------------------------------
BwDateTime.makeDtEnd and makeDtStart probably will not work.
They probably need to set the value after setting the timezone.
--------------------------------------------------------------------------------
addEventRef.do
What form of link do we build. Some form of url to the event
--------------------------------------------------------------------------------
Caldav
** Can set start before end - validate in CalSvc

** Was able to create 2 events - different guids same name

** CaldavComponentNode.init called from lastmod and gets multiple objects
   besides the inefficiency? We need to handle multiple objects for recurrences
   A node represents a name so all instances need to be packed into
   one node - example 7.6.3 shows this

   Filter.query should do this bit I think.

** Need to change back end to support limit-recurrence-set and expand
   time ranges (why they there anyway)

** getEventsByName needs to get any overrides

** Icalendar.toIcal(Collection) -- add timezones

** What response for mismatched name + guid

** Need to check that a put hasn't changed the calendar (can it?)

** Is 3.1.1.3 working OK? Returning timezone

** Is 3.1.1.4 working OK? Also returning timezone

** Report is ignoring depth

** Initial PUT of recurring event with overrides doesn't work.

** calendar-access in headers

** Was able to create 2 events with same guid and name

** Adding same (recurring) event twice seems to duplicate instances
   Try exd1 twice

** Hibernate seems to update objects just because they changed. Doesn't need
   explicit save?

** Message set on bad request exception isn't making it back to client. Try a
   duplicate guid for example.
--------------------------------------------------------------------------------
Caldav question(s)

+++
Is the draft inconsistent (or unclear) around
4.1 Calendar Object Resource

The vcalendar shown has 3 vevents and 2 uids. Spec say's

Calendar components in a calendar collection that have different UID
   property values MUST be stored in separate calendar object resources.

So we have 2 resources

5.3.2  says

 The Request-URI on the PUT request MUST include the target collection,
   where the resource is to be created, plus the name of the resource in
   the last path segment.

which seems to require 2 urls for each of those resources so they couldn't
appear in the same vcalendar object?

Or to put it another way caldav requires that each PUT only be for one
uid?
+++
What response for attempt to create duplicate guids?
bad-request + message?
--------------------------------------------------------------------------------
Delete in user calendar doesn't work
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Event_Attendees table has wrong column name
--------------------------------------------------------------------------------
Recurrences and proxies

1. Don't fetch master event for getEvents - needs a flag on recurrences
   Fetch if named explicitly - UNLESS we are being asked specifically for
   unexpanded events

2. Don't use master as first entry

3. Need to fix proxy events.
--------------------------------------------------------------------------------
Proxy events and/or annotations

What we're trying to solve here are a number of problems.

First we need to be able to modify an instance of a recurring event without
losing track of the changes to the master event. Modifying an instance means
changing the start date for instance but not missing changes to the master event
attendees.

Another case is very similar - we want to be able to annotate events we don't
have write access to - for example public events or events owned by a group or
user.

The mechanism might also be seen as a way of versioning events.

The approach is to create an event object which is empty and point it at the
target event. It has to be populated with the start date/time and the guid so
we can find it during the search. The guid is no problem - it never changes, the
dates are a problem as we'll see later.

Simple fields are relatively simple. For example the description. The process is
something like -

If the referring event has a value then use that, otherwise use the target event
value.

A problem occurs when the target event changes. Without tracking all changes to
the target we can't tell the user what changed. For example, user A annotates
the description only, then user B changes the target summary then there is no
need to notify user A. On the other hand if user B changes the description maybe
we should tell user A.

Collections are harder because we need to track changes to individual elements
as well as additions and deletions from the collection.

Probably we ought to save only the changes to collections and apply them at each
retrieval. That requires a field in the collection elements flagging that
element as a change.

Some implications:
When we update an event - if the event object is an annotation we need to
compare every field and see if it differs from the target. If not don't set the
annotation. The BwEventProxy object will do that for us.
--------------------------------------------------------------------------------
Timezones:
getMergedTimezones might be wrong - seems to assume at least a match in public

Need a two stage lookup in the timezones table
  1. static public timezone table
  2. non-static user timezone table

User lookup needs to be the owner of the event which contains the timezone. All
timezone info can be regarded as public I guess.

We should do a 3 stage lookup.
  1. In current user's table
  2. In event owners table if different
  3. In system table.

Also, for public events don't check any user table?

Is this ok? user was douglm
     [java] 10:48:52,041 DEBUG [CalSvcTimezones] trace: find timezone with id US/Eastern for owner null
     [java] 10:48:52,049 DEBUG [CalSvcTimezones] trace: register timezone with id US/Eastern
     [java] 10:48:52,049 DEBUG [IcalTranslator] Timezone already in db

--------------------------------------------------------------------------------
Status property
Use it in the client(s).
--------------------------------------------------------------------------------
Use guid (+recurrenceid) to fetch events
--------------------------------------------------------------------------------
Fix up messages.
--------------------------------------------------------------------------------
Users pluggable interface
--------------------------------------------------------------------------------
Preferences - mod/etc
Move some deploy time configuration stuff into pref.
--------------------------------------------------------------------------------
Quotas and limits - entity size and total
limit x-properties size?
--------------------------------------------------------------------------------
Manage calendars.

Check that access is limited to calendars to which auth user has at least
write-content access

Looks like we need to give super users specific access to the calendars.

Also delete needs to clean up beforehand
  - remove any subscriptions
  - which means remove subscriptions from views
--------------------------------------------------------------------------------
Do add/remove views in admin (and user)

url of form
http://localhost:8080/caladmin/addView.do?name=All
--------------------------------------------------------------------------------
Do add/remove/mod subscriptions

url of form
http://localhost:8080/ucal/subscribe.do?calid=16&name=Arts[&email=y/n][&freebusy=y/n][&view=Arts|addToDefaultView=y/n]

http://localhost:8080/ucal/unsubscribe.do?name=Arts
This needs to remove subscription from all views
--------------------------------------------------------------------------------
Simplify public events user/owner stuff
It all seems over complicated. For public events we have 3 users
1. The authenticated user - for access checks
2. The owner for objects created by that user - e.g. an admin group
3. The calendar system owner - for global entities such as prefs

For a personal user they are all the same thing. I think 1 and 2 could become
the same thing

For public calendars 3 is the owner of the preferences object which defines the
preferred view etc and also the view and subscription objects.
--------------------------------------------------------------------------------
A number of classes need to be marked serializable

Particularly HibSession
--------------------------------------------------------------------------------
Argentina holidays has a bunch of x-properties
--------------------------------------------------------------------------------
Uploads sort of work. Need to allow specification of receiving calendar.
--------------------------------------------------------------------------------
Access control testing
Caldav access reports probably need fixing
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

